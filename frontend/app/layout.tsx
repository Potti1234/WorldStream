import type { Metadata } from 'next'
import { Geist, Geist_Mono } from 'next/font/google'
import { MiniKitProvider } from '@worldcoin/minikit-js/minikit-provider';
import { VerificationProvider } from '@/contexts/verification-context';
import './globals.css'
import { Toaster } from '@/components/ui/sonner'
import { clientLogger } from "@/lib/client-logger";

const geistSans = Geist({
  variable: '--font-geist-sans',
  subsets: ['latin']
})

const geistMono = Geist_Mono({
  variable: '--font-geist-mono',
  subsets: ['latin']
})

export const metadata: Metadata = {
  title: 'Create Next App',
  description: 'Generated by create next app'
}

// Conditional MiniKit wrapper component
function ConditionalMiniKitProvider ({
  children
}: {
  children: React.ReactNode
}) {
  // Check if we're in a browser environment and if MiniKit is available
  if (typeof window !== 'undefined') {
    try {
      // Dynamic import to avoid SSR issues
      const {
        MiniKitProvider
      } = require('@worldcoin/minikit-js/minikit-provider')
      const { MiniKit } = require('@worldcoin/minikit-js')

      // Only wrap with MiniKitProvider if MiniKit is supported
      if (MiniKit && typeof MiniKit.isInstalled === 'function') {
        return <MiniKitProvider>{children}</MiniKitProvider>
      }
      clientLogger.info('MiniKit not available', {}, 'ConditionalMiniKitProvider');
    } catch (error) {
      clientLogger.error('Error while checking for MiniKit availability', error, 'ConditionalMiniKitProvider');
    }
  }

  // Fallback: return children without MiniKit wrapper
  return <>{children}</>
}

export default function RootLayout ({
  children
}: Readonly<{
  children: React.ReactNode
}>) {
  return (
    <html lang='en'>
      <MiniKitProvider>
        <VerificationProvider>
        <body
          className={`${geistSans.variable} ${geistMono.variable} antialiased`}
        >
          {children}
          <Toaster />
        </body>
      </VerificationProvider>
    </MiniKitProvider>
    </html>
  )
}
